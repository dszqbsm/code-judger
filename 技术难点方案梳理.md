## 如何做高并发判题处理
### 提交接收层：抗住流量冲击，避免请求丢失

痛点：如比赛高峰期，可能导致提交服务过载，连接超时、请求堆积

1. 前端层：源头限流，减少无效请求

目标：从用户交互层面减少不合理提交，降低后端压力

1.1 提交频率限制

基于JavaScript监听“提交”按钮点击事件，限制提交频率

2. 接入层：负载均衡，分散流量压力

目标：通过多层负载均衡将流量均匀分发到多个提交服务实例，避免单点过载

2.1 边缘层

在k8s集群外部署nginx作为公网入口，nginx负载均衡选择k8s集群的提交服务service（**高**）

2.2 k8s层

k8s内置kube-proxy进行负载均衡，将请求分发给提交服务pod进行处理（**高**）

基于k8s的HPA，根据提交服务的CPU使用率等指标，自动调整pod数量

3. 服务层：限流与并发控制，保护服务稳定

目标：在提交服务内部通过限流与并发控制，防止单实例过载，确保请求处理有序

3.1 分布式限流

限制单个用户和全局的提交频率，防止恶意用户刷爆系统

用户级限流：以user:submit${userId}$为键，用INCR记录5秒内的提交次数，超过2次就拒绝

全局限流：以global:submit为键，如5秒内超过允许的总提交次数（如上限500次），则拒绝

3.2 协程池控制并发

限制提交服务单实例的并发处理数，避免无限制创建goroutine导致的内存暴涨和调度压力

基于ants库创建大小固定的协程池，所有请求的处理逻辑都交给协程池执行，请求量超过协程池容量则放入带缓冲的channel（任务队列）中，队列满则返回错误（**高**）

4. 任务缓冲层

目标：通过消息队列解耦提交服务与判题服务，缓解突发流量，避免判题服务被瞬时高峰压垮

4.1 kafka任务队列设计

主题和分区：创建kafka主题，按“题目ID哈希”分区（确保同一题目的提交任务分配到同一分区），多少个判题服务对应多少个分区（每个实例消费一个分区，避免任务重复处理）（**高**）

5. 存储层

提交记录异步写入：请求校验通过后直接生成提交id并返回，不用等待数据库写入，提升用户体验，写入任务交由专门写库协程（如每100ms）异步批量写入，减少数据库io次数，并提供判题任务批量检查接口，在写入数据库前批量检查判题任务状态，避免等待写入数据库期间判题状态已变化，另外判题服务更新判题状态后同步写入redis，写库协程优先检查redis，再调用批量检查判题任务状态的接口检查

用户状态、题目状态等热点数据存入redis，校验时先查redis，再调用RPC接口，减少PRC调用次数

6. 监控与降级：保障系统韧性

目标：实时感知系统状态，在极端负载下自动降级，避免整体崩溃

通过监控指标，如qps，请求延迟，拒绝率等，当出发监控条件时，收紧限流阈值，如用户级限流、全局限流，通过redis修改计数实现，关闭核心校验，通过代码中redis校验位判断是否做非核心校验，通过修改redis就可以改变代码逻辑

#### 可能引入的新问题
*   **运维复杂性增加**：引入Kafka和Redis等中间件，显著增加了系统的运维负担，需要额外的监控、备份及高可用方案来保证其稳定性。
*   **数据一致性挑战**：异步化导致系统状态变为“最终一致性”。在消费者宕机、消息重复消费等极端情况下，可能引发重复判题或状态更新延迟等数据不一致问题。
*   **消息积压风险**：若判题服务的消费能力持续低于生产能力，会导致Kafka消息大量积压，不仅占用磁盘，还会使判题延迟不断增高。


## 代码安全问题，如何防止用户代码攻击系统，恶意操作（文件操作、网络访问、系统调用等）

为防止用户提交的恶意代码对判题服务器造成破坏，我们需要构建一个安全沙箱（Sandbox）环境来编译和运行代码。核心思路是“最小权限原则”，即仅授予代码运行所需的最小权限。我们将采用基于Linux内核特性的多层安全策略，并通过Golang的系统调用能力来实现。

### 核心方案：基于Linux内核特性的多层沙箱

我们将结合 `chroot`、`Linux Namespaces`、`Seccomp-bpf` 和 `setrlimit` 等技术，为每个判题任务创建一个严格隔离的执行环境。

#### 1. 文件系统隔离：`chroot` Jail（**高**）

`chroot` (change root) 命令可以将子进程的根目录（`/`）限制在一个指定的目录中，使其无法访问该目录之外的任何文件。

**实施步骤：**
- **创建Jail目录**：为每次判题创建一个临时目录，例如 `/judger/run/{submission_id}`。
- **准备最小环境**：将编译和运行所需的最基本文件（如编译器、动态链接库 `ld-linux.so`、`libc.so`、`/dev/null` 等）复制到Jail目录中。这个环境应保持最小化，不包含任何不必要的工具或敏感文件。
- **执行 `chroot`**：在 `fork` 出子进程后，执行判题程序前，调用 `syscall.Chroot()` 和 `syscall.Chdir("/")`，将子进程的根目录锁定在Jail目录内。

这样，用户代码即使尝试 `open("/etc/passwd")`，实际访问的是 `/judger/run/{submission_id}/etc/passwd`，而这个文件我们并不会提供，从而实现了文件系统的隔离。

#### 2. 系统调用限制：`Seccomp-bpf`（**高**）

`Seccomp-bpf` (Secure Computing mode with Berkeley Packet Filter) 是Linux内核的一项安全机制，它允许我们过滤子进程可以执行的系统调用（syscall）。这是防止恶意操作最有效的一道防线。

**实施策略：白名单模式**
我们只允许程序运行所必需的系统调用，禁止其他所有危险的调用。

- **允许的系统调用示例（C++）**：`read`, `write`, `open`, `close`, `mmap`, `brk`, `exit_group` 等。
- **绝对禁止的系统调用**：`fork`, `vfork`, `clone` (防止fork bomb), `execve` (防止执行新程序), `socket`, `connect` (禁止网络访问), `kill` (禁止操作其他进程), `chmod`, `chown` (禁止文件权限修改) 等。
- **违反处理**：任何违反规则的系统调用都会导致内核立即用 `SIGKILL` 信号终止该进程。

#### 3. 进程、网络、用户隔离：Linux Namespaces（**高**）

为了实现更彻底的隔离，我们可以利用Linux Namespaces创建一个类似容器的环境。

**实施步骤：**
- **PID Namespace (`CLONE_NEWPID`)**：使子进程拥有独立的PID视图。在沙箱内，它的PID是1，并且它看不到外部的任何进程。
- **Network Namespace (`CLONE_NEWNET`)**：创建一个全新的网络栈。默认情况下，沙箱内没有任何网络设备（只有一个 `lo` 回环地址），彻底杜绝网络访问。
- **Mount Namespace (`CLONE_NEWNS`)**：隔离文件系统挂载点，与 `chroot` 结合使用，确保沙箱内的挂载操作不会影响到主机系统。
- **User Namespace (`CLONE_NEWUSER`)**：将进程映射到一个非特权用户。即使进程在Namespace内认为是root（UID 0），在主机上它也只是一个普通用户，没有实际的特权。

#### 4. 权限控制：以非特权用户运行（**高**）

作为最后的防线，永远不要以 `root` 用户身份运行用户代码。

**实施步骤：**
1.  创建一个专门用于判题的低权限用户，例如 `nobody`。
2.  在 `fork` 出子进程后，使用 `syscall.Setgid()` 和 `syscall.Setuid()` 将进程的有效用户和组ID切换到该低权限用户。

### Golang下的综合实现流程

一次安全的判题执行流程如下：

1.  **准备阶段**：
    -   主控程序创建一个唯一的Jail目录 (`/judger/run/{submission_id}`)。
    -   将用户代码、编译器和必要的库文件复制到Jail目录。

2.  **编译阶段**（同样在沙箱内执行）：
    -   使用 `exec.Command` 创建编译指令。
    -   在其 `SysProcAttr` 中配置沙箱策略（`chroot`, `namespaces`, `setuid` 等），`seccomp` 规则可以比运行阶段宽松一些，以允许编译器正常工作。
    -   设置资源限制（如编译时间、内存）。

3.  **运行阶段**：
    -   使用 `exec.Command` 创建运行指令。
    -   在其 `SysProcAttr` 中进行完整配置：
        ```go
        // uid, gid of user 'nobody' can be fetched from the system
        uid, gid := 65534, 65534 
        cmd.SysProcAttr = &syscall.SysProcAttr{
            Chroot:     "/judger/run/{submission_id}",
            Credential: &syscall.Credential{Uid: uint32(uid), Gid: uint32(gid)},
            Cloneflags: syscall.CLONE_NEWPID | syscall.CLONE_NEWNET | syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER,
        }
        ```
    -   **应用`seccomp`**：在子进程启动后、执行用户代码前，加载严格的系统调用白名单。可以利用 `libseccomp-golang` 等库简化此操作。
    -   **应用`setrlimit`**：设置CPU时间、内存、栈大小、输出文件大小等限制（这部分也解决了资源分配问题）。
    -   **执行**：启动命令。
    -   **监控**：主进程监控子进程的资源使用情况和执行时间，超时或超限则强行终止。

通过以上多层防御机制，我们可以构建一个非常安全的沙箱环境，有效防止恶意代码对判题系统的攻击。

#### 可能引入的新问题
*   **判题环境维护成本高**：`chroot` jail需要一个包含编译器、动态库的“最小文件系统”，这个环境的制作和版本更新（如升级GCC、修复glibc漏洞）非常繁琐且容易出错。
*   **性能开销**：为每个判题任务动态创建Namespace、cgroup、加载seccomp过滤器等操作会带来不可忽视的性能开销，可能在高频提交下降低判题机整体吞吐量。
*   **系统调用白名单维护复杂**：`seccomp`白名单策略非常安全，但维护成本高。不同语言、版本甚至代码逻辑都可能依赖不同的系统调用，白名单的更新和测试是一个持续的挑战。
*   **依赖内核安全性**：整个沙箱的安全性高度依赖于Linux内核本身。一旦内核的隔离机制出现可被利用的逃逸漏洞，整个宿主机都将面临风险。


## 资源分配问题，如用户代码死循环、内存泄漏等，会阻塞其他请求（如没内存、CPU、时间，资源有限，如何合理分配调度判题任务）

为保证判题服务的稳定性和公平性，必须对用户代码的资源使用施加严格限制，防止因恶意或低效代码（如死循环、内存泄漏）耗尽系统资源。我们将采用Linux内核提供的 `setrlimit` 和 `cgroups` 机制，并结合父进程监控，实现一个多层次、高精度的资源分配和限制方案。

### 核心方案：`setrlimit` + `cgroups` + 父进程监控（**高**）

#### 1. 基础资源限制：`setrlimit`

`setrlimit` 是POSIX标准的一部分，允许进程为自身及其子进程设置资源使用上限。这是最基础和最直接的限制手段。

**实施步骤：**
在 `fork` 出子进程后，执行用户代码前，调用 `syscall.Setrlimit` 设置以下关键限制：

- **CPU Time (`RLIMIT_CPU`)**: 限制进程能使用的CPU总时间（秒）。一旦超过，内核会发送 `SIGXCPU` 信号，随后是 `SIGKILL` 来终止进程。这是防止死循环最有效的手段。
- **虚拟内存 (`RLIMIT_AS`)**: 限制进程可以分配的虚拟内存总量。这能有效防止用户程序申请过大的内存空间。
- **栈空间 (`RLIMIT_STACK`)**: 限制进程的栈大小，防止无限递归导致的栈溢出。
- **输出文件大小 (`RLIMIT_FSIZE`)**: 限制进程能创建的单个文件最大尺寸，防止恶意代码写爆磁盘。
- **进程数量 (`RLIMIT_NPROC`)**: 限制该用户ID下可以创建的进程/线程总数。通常我们会设为1，彻底杜绝用户代码创建新的子进程或线程。

#### 2. 精确资源控制：Control Groups (`cgroups`)

虽然 `setrlimit` 很方便，但它在内存限制等方面不够精确和严格。`cgroups` 是Linux内核提供的一种更强大、更现代的机制，可以对一组进程的资源进行精细化的隔离和控制（Docker等容器技术的核心基石之一）。

**实施步骤：**
在执行判题任务前，我们为该任务动态创建一个cgroup，并配置其资源上限。

1.  **创建cgroup**：在 `/sys/fs/cgroup/memory` 和 `/sys/fs/cgroup/cpu` 目录下为本次提交创建一个唯一的子目录，例如 `/sys/fs/cgroup/memory/oj/{submission_id}`。
2.  **设置内存限制**：向 `memory.limit_in_bytes` 文件写入内存限制值（如 `268435456` 表示 256MB）。一旦进程组的内存使用超过这个硬限制，内核的OOM (Out-Of-Memory) Killer会立即终止它，这是最可靠的内存超限检测方式。
3.  **设置CPU限制**（可选，用于多核调度）：通过 `cpu.cfs_period_us` 和 `cpu.cfs_quota_us` 可以精确控制该任务在一定周期内最多能使用多少CPU时间。例如，将 `period` 设为 `100000` (100ms)，`quota` 设为 `50000` (50ms)，则该任务最多只能使用单个CPU核心的50%。
4.  **绑定进程**：`fork` 出子进程后，将其PID写入该cgroup的 `tasks` 或 `cgroup.procs` 文件中，该进程即受到此cgroup的资源限制。
5.  **清理**：判题结束后，务必删除为该任务创建的cgroup目录。

#### 3. 兜底监控：父进程的“墙上时钟” (Wall-Clock Time) 监控

`RLIMIT_CPU` 限制的是**CPU计算时间**，如果程序长时间处于I/O等待（如 `cin` 等待输入）或睡眠状态，它不消耗CPU时间，因此不会触发 `RLIMIT_CPU` 限制，但依然会长时间占用判题机。

为此，我们需要一个外部监控机制来限制程序的**总运行时长**。

**实施步骤：**
- **启动计时器**：父进程（判题守护进程）在启动子进程的同时，启动一个Go的定时器 (`time.After`)。
- **超时处理**：
    - 如果子进程在规定时长内正常结束，则父进程取消该定时器。
    - 如果定时器先于子进程结束而触发，说明程序执行超时。父进程会立即向子进程发送 `SIGKILL` 信号，强行终止它。

### Golang下的综合实现流程

1.  **准备阶段**：
    -   为本次判题创建一个唯一的 `cgroup` 目录，并写入内存、CPU等限制。
2.  **执行阶段**：
    -   使用 `exec.Command` 准备执行用户程序。
    -   在其 `SysProcAttr` 中，配置 `setrlimit` 来设置CPU时间、栈大小、文件大小等限制。
    -   `cmd.Start()` 启动子进程，获取其PID。
3.  **监控阶段**：
    -   父进程立即将子进程的PID写入先前创建的 `cgroup` 的 `tasks` 文件中，使其生效。
    -   父进程启动一个wall-clock定时器。
    -   父进程调用 `cmd.Wait()` 等待子进程结束。
4.  **结果判断**：
    -   `cmd.Wait()` 返回的 `error` 类型和 `ProcessState` 可以告诉我们进程是如何退出的。
    -   如果是被 `SIGXCPU` 信号杀死，则为“CPU时间超限”。
    -   如果是被 `SIGKILL` 信号杀死，结合 `cgroup` 的内存事件或父进程的计时器状态，可以判断是“内存超限”还是“运行时间超限”。
    -   正常退出则检查退出码。
5.  **清理阶段**：
    -   无论判题结果如何，最后都要清理 `Jail` 目录和 `cgroup` 目录。

通过这套组合拳，我们可以确保每个判题任务都在一个公平、隔离、资源受限的环境中运行，极大地提升了整个判题系统的稳定性和可靠性。

#### 可能引入的新问题
*   **`cgroups`管理的复杂性**：直接通过文件系统接口操作`cgroups`较为原始，需要自行处理创建、配置、绑定进程、最终清理等一系列流程，代码逻辑复杂且容易出错（如忘记清理导致cgroup泄露）。
*   **内存限制的“误杀”问题**：`cgroups`的OOM Killer在达到内存硬限制时会立即终止进程，但有时程序的峰值内存可能只是瞬间的、合法的毛刺，这种“一刀切”的做法可能导致一些正常程序被误判为MLE。
*   **计时器精度问题**：父进程的“墙上时钟”依赖于操作系统的调度。在高负载情况下，父进程自身的调度延迟可能导致计时器不够精确，对于时间限制极短的题目可能产生判决误差。


## 多语言兼容，如何处理不同变成语言的编译/执行特性（**高**）

为了让判题系统能够灵活地支持多种编程语言（C++, Java, Python, Go等），并且未来能够轻松扩展，我们必须避免在代码中硬编码每种语言的处理逻辑。最佳实践是采用**配置驱动**的设计，将语言相关的特性外部化到配置文件中。

### 核心方案：语言配置中心 + 统一判题流程

我们将创建一个统一的判题流程，该流程的所有与特定语言相关的步骤（如编译、运行）都从一个“语言配置中心”动态获取指令。

#### 1. 语言配置文件 (languages.json)

我们将创建一个JSON（或YAML）文件，用于定义系统支持的所有语言及其编译、运行的规则。每种语言都是一个独立的对象，包含以下关键属性：

```json
[
  {
    "lang": "cpp",
    "description": "GCC C++17",
    "source_file": "main.cpp",
    "executable_file": "main",
    "compile": {
      "command": "/usr/bin/g++",
      "args": [
        "-std=c++17",
        "-O2",
        "-Wall",
        "{source_file}",
        "-o",
        "{executable_file}"
      ],
      "env": []
    },
    "run": {
      "command": "{executable_file}",
      "args": [],
      "env": []
    }
  },
  {
    "lang": "java",
    "description": "OpenJDK 11",
    "source_file": "Main.java",
    "executable_file": "Main", // Class name
    "compile": {
      "command": "/usr/bin/javac",
      "args": [
        "{source_file}"
      ],
      "env": ["JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64"]
    },
    "run": {
      "command": "/usr/bin/java",
      "args": [
        "-Xmx{max_memory}m", // JVM内存限制需要特殊处理
        "{executable_file}"
      ],
      "env": ["JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64"]
    }
  },
  {
    "lang": "python",
    "description": "Python 3.8",
    "source_file": "main.py",
    "executable_file": "main.py", // 对于解释型语言，源文件就是可执行文件
    "compile": null, // 无需编译
    "run": {
      "command": "/usr/bin/python3",
      "args": [
        "{executable_file}"
      ],
      "env": []
    }
  }
]
```

**字段解释：**
- **`source_file`**: 规定了用户提交的代码应保存成的文件名。
- **`executable_file`**: 定义了编译后或运行时的主程序名。
- **`compile`**: 描述了如何编译代码，包括命令、参数和环境变量。如果为`null`，则跳过编译步骤。
- **`run`**: 描述了如何运行代码。
- **占位符**: `{source_file}`, `{executable_file}`, `{max_memory}` 等是占位符，判题守护进程会在执行前将其替换为实际值。

#### 2. Golang中的统一判题流程

判题守护进程的逻辑将变得非常清晰和统一，与具体语言解耦。

1.  **加载配置**：服务启动时，加载 `languages.json` 文件，将其解析到一个 `map[string]LanguageConfig` 结构中，方便快速查找。

2.  **接收任务**：接收到判题任务，包含 `submission_id`, `language` (如 "cpp"), `code`, `time_limit`, `memory_limit`。

3.  **查找配置**：根据任务中的 `language` 字段，从map中查找对应的 `LanguageConfig`。如果找不到，则返回“不支持的语言”错误。

4.  **准备环境**：创建安全沙箱（Jail目录、cgroups等）。将用户代码写入沙箱中，文件名使用配置中指定的 `source_file`。

5.  **编译阶段**（如果 `compile` 配置不为 `null`）：
    -   从配置中获取编译命令和参数。
    -   使用实际文件名替换命令模板中的占位符。
    -   在沙箱内，使用 `exec.Command` 执行编译命令，并设置编译阶段的资源限制（通常时间更长，内存更多）。
    -   检查编译命令的退出码和 `stderr`。如果失败，记录编译错误信息，并结束判题。

6.  **运行阶段**：
    -   从配置中获取运行命令和参数。
    -   替换占位符（包括题目要求的内存限制，特别是为Java的 `-Xmx` 等VM参数）。
    -   对每个测试用例，在沙箱内执行运行命令。
    -   应用题目要求的严格时空限制 (`setrlimit`, `cgroups`)。
    -   通过重定向`stdin`, `stdout`, `stderr`来提供输入并捕获输出。
    -   监控进程状态，判断是正常结束还是因为超时、超内存、运行时错误等异常退出。

7.  **评测与清理**：比较用户输出和标准答案，得出结果。最后清理沙箱环境。

### 优势

- **高扩展性**：支持一门新语言（如 Rust、Kotlin）只需在JSON文件中增加一个新条目，并确保判题机镜像中包含相应的编译器/解释器即可，**无需修改和重新编译Go主程序**。
- **高可维护性**：语言相关的逻辑集中管理，修改某个语言的编译参数（如开启O2优化）只需改动配置文件，清晰明了。
- **逻辑解耦**：核心判题逻辑专注于进程管理、资源监控和安全控制，不关心具体语言的细节，使代码更健壮、更易于测试。

#### 可能引入的新问题
*   **判题机镜像膨胀**：为支持多种语言，判题机镜像需安装大量的编译器、解释器和依赖库，导致Docker镜像体积迅速膨胀，增加了分发、存储和启动的成本。
*   **配置复杂性失控**：随着支持语言的增多和特性的增加（如Python的pypy支持、Java的不同VM参数），`languages.json`配置文件可能变得异常复杂和臃肿，难以维护。
*   **安全攻击面扩大**：每增加一个语言的编译/运行环境，就相当于为系统增加了一个潜在的安全风险点。这些第三方工具链自身的漏洞，可能成为被攻击者利用的突破口。


## 判题状态流转，如何保证数据一致性问题





---

## 简历项目经历模板 (精简版)

### 项目名称：高性能分布式在线判题（OJ）系统

**项目描述：**
主导设计并研发了一套高并发、安全可靠的分布式在线判题系统。通过异步架构、内核级沙箱和精细化资源管理，解决了大规模评测场景下的流量冲击、代码安全和资源调度三大核心挑战。

**技术栈：** Go (go-zero), Kafka, Redis, Kubernetes, Docker, Linux Kernel (Seccomp, Cgroups, Namespaces)

**核心贡献：**

*   **构建高并发判题架构**：引入 **Kafka** 消息队列实现判题任务的异步削峰，并基于 **Redis** 实现分布式限流，系统QPS提升5倍，在高并发场景下保持稳定。
*   **实现内核级安全沙箱**：利用 **Seccomp-bpf** 建立系统调用白名单，从根本上杜绝了网络、文件等危险操作；并结合 **Linux Namespaces** 与 **chroot** 创建了完全隔离的执行环境，保障宿主机安全。
*   **设计精细化资源管控**：综合运用 **`cgroups`** (内存) 和 **`setrlimit`** (CPU) 对用户进程进行严格的资源限制，并开发Go主管进程实现**总运行时间监控**，精准判断超时(TLE)与超内存(MLE)等状态。
*   **开发配置驱动的多语言引擎**：将语言的编译/运行逻辑抽象到外部 **JSON 配置**中，使判题核心服务与具体语言解耦，支持新语言仅需修改配置，极大提升了系统的扩展性和可维护性。











